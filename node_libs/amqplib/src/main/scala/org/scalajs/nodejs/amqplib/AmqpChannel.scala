package org.scalajs.nodejs.amqplib

import org.scalajs.nodejs.buffer.Buffer
import org.scalajs.nodejs.errors
import org.scalajs.nodejs.events.EventEmitter
import org.scalajs.nodejs.events.EventEmitter

import scala.concurrent.ExecutionContext
import scala.scalajs.js

/**
  * AMQP Channel
  * @author lawrence.daniels@gmail.com
  */
@js.native
trait AmqpChannel extends EventEmitter {

  /**
    * Close a channel. Will be resolved with no value once the closing handshake is complete.
    * There's not usually any reason to close a channel rather than continuing to use it until you're ready to close
    * the connection altogether. However, the lifetimes of consumers are scoped to channels, and thereby other things
    * such as exclusive locks on queues, so it is occasionally worth being deliberate about opening and closing channels.
    * @return a promise of the closed status
    */
  def close(): js.Promise[errors.Error] = js.native

  /**
    * Close a channel. Will be resolved with no value once the closing handshake is complete.
    * There's not usually any reason to close a channel rather than continuing to use it until you're ready to close
    * the connection altogether. However, the lifetimes of consumers are scoped to channels, and thereby other things
    * such as exclusive locks on queues, so it is occasionally worth being deliberate about opening and closing channels.
    * @param callback the closed status callback
    */
  def close(callback: js.Function): Unit = js.native

  /////////////////////////////////////////////////////////////////////////////////
  //      Consumers and Messages
  /////////////////////////////////////////////////////////////////////////////////

  def ack(message: AmqpMessage): js.Promise[Boolean] = js.native

  def ack(message: AmqpMessage, callback: js.Function): Unit = js.native

  /**
    * Acknowledge all outstanding messages on the channel. This is a "safe" operation, in that it won't result in
    * an error even if there are no such messages.
    * @return the promise of a result
    */
  def ackAll(): js.Promise[Boolean] = js.native

  /**
    * This instructs the server to stop sending messages to the consumer identified by consumerTag. Messages may
    * arrive between sending this and getting its reply; once the reply has resolved, however, there will be no
    * more messages for the consumer, i.e., the message callback will no longer be invoked.
    * @param consumerTag is the string given in the reply to #consume, which may have been generated by the server.
    * @return a promise of the result
    */
  def cancel(consumerTag: String): js.Promise[Boolean] = js.native

  /**
    * This instructs the server to stop sending messages to the consumer identified by consumerTag. Messages may
    * arrive between sending this and getting its reply; once the reply has resolved, however, there will be no
    * more messages for the consumer, i.e., the message callback will no longer be invoked.
    * @param consumerTag is the string given in the reply to #consume, which may have been generated by the server.
    * @param callback    the results callback
    */
  def cancel(consumerTag: String, callback: js.Function): Unit = js.native

  /**
    * Reject a message. This instructs the server to either requeue the message or throw it away (which may
    * result in it being dead-lettered).
    * @param message the message to reject.
    * @param allUpTo If allUpTo is truthy, all outstanding messages prior to and including the given message are rejected.
    *                As with #ack, it's a channel-ganking error to use a message that is not outstanding. Defaults to false.
    * @param requeue If requeue is truthy, the server will try to put the message or messages back on the queue or queues
    *                from which they came. Defaults to true if not given, so if you want to make sure messages are
    *                dead-lettered or discarded, supply false here.
    */
  def nack(message: AmqpMessage, allUpTo: Boolean = false, requeue: Boolean = false): js.Promise[js.Any] = js.native

  /**
    * Reject all messages outstanding on this channel. If requeue is truthy, or omitted, the server will try to
    * re-enqueue the messages.
    * @param requeue If requeue is truthy, the server will try to put the message or messages back on the queue or queues
    *                from which they came. Defaults to true if not given, so if you want to make sure messages are
    *                dead-lettered or discarded, supply false here.
    */
  def nackAll(requeue: Boolean = false): js.Promise[js.Any] = js.native

  /**
    * Set the prefetch count for this channel. The count given is the maximum number of messages sent over the channel
    * that can be awaiting acknowledgement; once there are count messages outstanding, the server will not send more
    * messages on this channel until one or more have been acknowledged. A falsey value for count indicates no such limit.
    * @param count  the specified count of messages outstanding
    * @param global Use the global flag to get the per-channel behaviour. To keep life interesting, using the global
    *               flag with an RabbitMQ older than v3.3.0 will bring down the whole connection.
    */
  def prefetch(count: Int, global: Boolean = false): js.Promise[js.Any] = js.native

  /**
    * Requeue unacknowledged messages on this channel. The server will reply (with an empty object) once all messages are requeued.
    * @param callback the results callback
    */
  def recover(callback: js.Function): Unit = js.native

  /**
    * Reject a message. Equivalent to #nack(message, false, requeue), but works in older versions of RabbitMQ (< v2.3.0)
    * where #nack does not.
    * @param message the message to reject.
    * @param requeue If requeue is truthy, the server will try to put the message or messages back on the queue or queues
    *                from which they came. Defaults to true if not given, so if you want to make sure messages are
    *                dead-lettered or discarded, supply false here.
    */
  def reject(message: AmqpMessage, requeue: Boolean = false): js.Promise[js.Any] = js.native

  /////////////////////////////////////////////////////////////////////////////////
  //      Exchanges
  /////////////////////////////////////////////////////////////////////////////////

  def assertExchange(exchange: String, options: ExchangeOptions = null): js.Promise[Boolean] = js.native

  def assertExchange(exchange: String, options: ExchangeOptions, callback: js.Function): Unit = js.native

  def assertExchange(exchange: String, callback: js.Function): Unit = js.native

  def bindExchange(exchange: String, source: String, pattern: String, args: js.Any = null): js.Promise[Boolean] = js.native

  def bindExchange(exchange: String, source: String, pattern: String, args: js.Any, callback: js.Function): Unit = js.native

  def bindExchange(exchange: String, source: String, pattern: String, callback: js.Function): Unit = js.native

  def checkExchange(exchange: String): js.Promise[Boolean] = js.native

  def checkExchange(exchange: String, callback: js.Function): Unit = js.native

  def deleteExchange(name: String, options: js.Any = null): js.Promise[Boolean] = js.native

  def deleteExchange(name: String, options: js.Any, callback: js.Function): Unit = js.native

  def deleteExchange(name: String, callback: js.Function): Unit = js.native

  def publish(exchange: String, routingKey: String, content: String, options: js.Any = null): js.Promise[Boolean] = js.native

  def unbindExchange(exchange: String, source: String, pattern: String, args: js.Any = null): js.Promise[Boolean] = js.native

  def unbindExchange(exchange: String, source: String, pattern: String, args: js.Any, callback: js.Function): Unit = js.native

  def unbindExchange(exchange: String, source: String, pattern: String, callback: js.Function): Unit = js.native

  /////////////////////////////////////////////////////////////////////////////////
  //      Queues
  /////////////////////////////////////////////////////////////////////////////////

  /**
    * Assert a queue into existence. This operation is idempotent given identical arguments; however, it will bork the
    * channel if the queue already exists but has different properties (values supplied in the arguments field may or
    * may not count for borking purposes; check the borker's, I mean broker's, documentation).
    * @param queue   the queue is a string; if you supply an empty string or other falsey value (including null
    *                and undefined), the server will create a random name for you.
    * @param options the queue options
    * @return a promise of the assertion result
    */
  def assertQueue(queue: String, options: QueueOptions = null): js.Promise[Boolean] = js.native

  /**
    * Assert a queue into existence. This operation is idempotent given identical arguments; however, it will bork the
    * channel if the queue already exists but has different properties (values supplied in the arguments field may or
    * may not count for borking purposes; check the borker's, I mean broker's, documentation).
    * @param queue    the queue is a string; if you supply an empty string or other falsey value (including null
    *                 and undefined), the server will create a random name for you.
    * @param options  the queue options
    * @param callback the assertion result callback
    */
  def assertQueue(queue: String, options: QueueOptions, callback: js.Function): Unit = js.native

  /**
    * Assert a queue into existence. This operation is idempotent given identical arguments; however, it will bork the
    * channel if the queue already exists but has different properties (values supplied in the arguments field may or
    * may not count for borking purposes; check the borker's, I mean broker's, documentation).
    * @param queue    the queue is a string; if you supply an empty string or other falsey value (including null
    *                 and undefined), the server will create a random name for you.
    * @param callback the assertion result callback
    */
  def assertQueue(queue: String, callback: js.Function): Unit = js.native

  def bindQueue(queue: String, source: String, pattern: String, args: js.Any = null): js.Promise[Boolean] = js.native

  def bindQueue(queue: String, source: String, pattern: String, args: js.Any, callback: js.Function): Unit = js.native

  def bindQueue(queue: String, source: String, pattern: String, callback: js.Function): Unit = js.native

  /**
    * Check whether a queue exists. This will bork the channel if the named queue doesn't exist; if it does exist,
    * you go through to the next round! There's no options, unlike #assertQueue(), just the queue name. The reply
    * from the server is the same as for #assertQueue().
    * @param queue the queue string
    * @return a promise of the status
    */
  def checkQueue(queue: String): js.Promise[Boolean] = js.native

  /**
    * Check whether a queue exists. This will bork the channel if the named queue doesn't exist; if it does exist,
    * you go through to the next round! There's no options, unlike #assertQueue(), just the queue name. The reply
    * from the server is the same as for #assertQueue().
    * @param queue    the queue string
    * @param callback the results callback
    */
  def checkQueue(queue: String, callback: js.Function): Unit = js.native

  /**
    * Sets up a consumer with a callback to be invoked with each message.
    * @param queue       the named queue
    * @param consumption the message consumption callback
    * @param options     the optional options
    */
  def consume(queue: String, consumption: js.Function, options: js.Any = null): js.Promise[Boolean] = js.native

  /**
    * Sets up a consumer with a callback to be invoked with each message.
    * @param queue       the named queue
    * @param consumption the message consumption callback
    * @param callback    the results/status callback
    * @param options     the optional options
    */
  def consume(queue: String, consumption: js.Function, callback: js.Function, options: js.Any): Unit = js.native

  /**
    * Sets up a consumer with a callback to be invoked with each message.
    * @param queue       the named queue
    * @param consumption the consumption callback
    * @param callback    the results/status callback
    */
  def consume(queue: String, consumption: js.Function, callback: js.Function): Unit = js.native

  /**
    * Delete the queue named. Naming a queue that doesn't exist will result in the server closing the channel,
    * to teach you a lesson (except in RabbitMQ version 3.2.0 and after1)
    * @param queue   the queue string
    * @param options the options
    * @return a promise of the deletion results
    */
  def deleteQueue(queue: String, options: QueueOptions = null): js.Promise[Boolean] = js.native

  /**
    * Delete the queue named. Naming a queue that doesn't exist will result in the server closing the channel,
    * to teach you a lesson (except in RabbitMQ version 3.2.0 and after1)
    * @param queue    the queue string
    * @param options  the options
    * @param callback the deletion results callback
    */
  def deleteQueue(queue: String, options: QueueOptions, callback: js.Function): Unit = js.native

  /**
    * Delete the queue named. Naming a queue that doesn't exist will result in the server closing the channel,
    * to teach you a lesson (except in RabbitMQ version 3.2.0 and after1)
    * @param queue    the queue string
    * @param callback the deletion results callback
    */
  def deleteQueue(queue: String, callback: js.Function): Unit = js.native

  /**
    * Ask a queue for a message, as an RPC. This will be resolved with either false, if there is no message to be had
    * (the queue has no messages ready), or a message in the same shape as detailed in #consume
    * @param queue   the named queue
    * @param options the optional ACK / no ACK options
    * @return a promise of a message
    */
  def get(queue: String, options: NoAckOptions = null): js.Promise[Any] = js.native

  /**
    * Ask a queue for a message, as an RPC. This will be resolved with either false, if there is no message to be had
    * (the queue has no messages ready), or a message in the same shape as detailed in #consume
    * @param queue    the named queue
    * @param options  the optional ACK / no ACK options
    * @param callback the results callback
    */
  def get(queue: String, options: NoAckOptions, callback: js.Function): Unit = js.native

  /**
    * Ask a queue for a message, as an RPC. This will be resolved with either false, if there is no message to be had
    * (the queue has no messages ready), or a message in the same shape as detailed in #consume
    * @param queue    the named queue
    * @param callback the results callback
    */
  def get(queue: String, callback: js.Function): Unit = js.native

  /**
    * Remove all undelivered messages from the queue named. Note that this won't remove messages that have been
    * delivered but not yet acknowledged; they will remain, and may be requeued under some circumstances
    * (e.g., if the channel to which they were delivered closes without acknowledging them).
    * @param queue the named queue
    * @return the promise of the result
    */
  def purgeQueue(queue: String): js.Promise[Boolean] = js.native

  /**
    * Remove all undelivered messages from the queue named. Note that this won't remove messages that have been
    * delivered but not yet acknowledged; they will remain, and may be requeued under some circumstances
    * (e.g., if the channel to which they were delivered closes without acknowledging them).
    * @param queue    the named queue
    * @param callback the results callback
    */
  def purgeQueue(queue: String, callback: js.Function): Unit = js.native

  /**
    * Send a single message with the content given as a buffer to the specific queue named, bypassing routing.
    * The options and return value are exactly the same as for #publish.
    * @param queue
    * @param content
    * @param options
    */
  def sendToQueue(queue: String, content: Buffer, options: js.Any = null): js.Promise[Boolean] = js.native

  def unbindQueue(queue: String, source: String, pattern: String, args: js.Any = null): js.Promise[Boolean] = js.native

  def unbindQueue(queue: String, source: String, pattern: String, args: js.Any, callback: js.Function): Unit = js.native

  def unbindQueue(queue: String, source: String, pattern: String, callback: js.Function): Unit = js.native

}

/**
  * AMQP Channel Companion
  * @author lawrence.daniels@gmail.com
  */
object AmqpChannel {

  /**
    * AMQP Channel Extensions
    * @param channel the given [[AmqpChannel channel]]
    */
  implicit class AmqpChannelExtensions(val channel: AmqpChannel) extends AnyVal {

    /**
      * Sets up a consumer with a callback to be invoked with each message.
      * @param queue       the named queue
      * @param options     the optional options
      * @param consumption the message consumption callback
      * @return the promise of a consumption result
      */
    @inline
    def consumeFuture(queue: String, options: js.Any = null)(consumption: AmqpMessage => Any) = {
      channel.consume(queue, consumption: js.Function, options).toFuture
    }

    /**
      * Ask a queue for a message, as an RPC. This will be resolved with either false, if there is no message to be had
      * (the queue has no messages ready), or a message in the same shape as detailed in #consume
      * @param queue   the named queue
      * @param options the optional ACK / no ACK options
      * @return a promise of the option of a message
      */
    @inline
    def getFuture(queue: String, options: NoAckOptions = null)(implicit ec: ExecutionContext) = {
      channel.get(queue, options).toFuture map {
        case v: Boolean => None
        case v => Option(v.asInstanceOf[AmqpMessage])
      }
    }

    /**
      * Emitted when a RabbitMQ server (after version 3.2.0) decides to block the connection. Typically it will do
      * this if there is some resource shortage, e.g., memory, and messages are published on the connection. See
      * the RabbitMQ documentation for this extension for details.
      * @param callback the event callback
      */
    @inline
    def onBlocked(callback: js.Function) = channel.on("blocked", callback)

    /**
      * Emitted once the closing handshake initiated by #close() has completed; or, if server closed the connection,
      * once the client has sent the closing handshake; or, if the underlying stream (e.g., socket) has closed.
      * @param callback the event callback
      */
    @inline
    def onClose(callback: js.Function) = channel.on("close", callback)

    /**
      * Emitted if the connection closes for a reason other than #close being called or a graceful server-initiated close.
      * @param callback the event callback
      */
    @inline
    def onError(callback: js.Function) = channel.on("error", callback)

    /**
      * Emitted at some time after 'blocked', once the resource shortage has alleviated.
      * @param callback the event callback
      */
    @inline
    def onUnblocked(callback: js.Function) = channel.on("unblocked", callback)

  }

}